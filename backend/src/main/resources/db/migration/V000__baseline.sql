-- =========================================================
-- Dorm Convenience System — 10주 MVP 통합 스키마 (ALL-IN-ONE)
--  • 범위: 확장 → 테이블/제약/트리거/뷰 → 초기 인덱스(개선안2) → 핫픽스(뷰/체크) → (옵션) TRGM
--  • 트랜잭션: 전체를 한 번에 실행 가능 (CONCURRENTLY 사용 안 함)
--  • 시각: timestamptz = UTC 보관 (표시는 클라이언트에서 KST)
--  • 원칙: 핵심 불변성은 DB가 보장(UNIQUE/CHECK/TRIGGER), 그 외 정책은 앱에서 처리
--  • 실시간: 포그라운드 = SSE, 백그라운드 = (포스트-MVP) Web Push
-- =========================================================

BEGIN;

-- ---------------------------------------------------------
-- 0) 확장
--    - citext: 아이디/이메일 고유성 검사에서 대소문자 무시
--    - btree_gist: EXCLUDE 제약 대비(이후 예약/시간 겹침 등에 활용)
--    - pg_trgm: (옵션) LIKE/검색 성능 향상(초기엔 비활성/소규모면 생략 가능)
-- ---------------------------------------------------------
CREATE EXTENSION IF NOT EXISTS citext;       -- 대소문자 무시 문자열(아이디 고유성)
CREATE EXTENSION IF NOT EXISTS btree_gist;   -- (향후 EXCLUDE 제약 대비)
CREATE EXTENSION IF NOT EXISTS pg_trgm;      -- (옵션) 키워드 검색 최적화

-- ---------------------------------------------------------
-- 1) 사용자/역할 (로컬 계정)
--    - 로그인은 아이디(username) + 비밀번호(해시)
--    - email은 선택(운영/알림 용도), NULL 다중 허용
--    - roles/user_roles로 단순 RBAC(ADMIN/INSPECTOR/USER)
-- ---------------------------------------------------------
CREATE TABLE IF NOT EXISTS users (
  user_id         BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- 사용자 ID(식별용)
  username        CITEXT NOT NULL UNIQUE,        -- 로그인 아이디(대소문자 무시 고유)
  password_hash   TEXT   NOT NULL,               -- Argon2id/bcrypt 해시(평문 저장 금지)
  display_name    TEXT   NOT NULL,               -- 사용자 표시명 이렇게 작성해야 함
  email           CITEXT UNIQUE,                 -- 선택 저장(여러 NULL 허용)
  is_active       BOOLEAN NOT NULL DEFAULT TRUE, -- false면 로그인 차단
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now()
);


CREATE TABLE IF NOT EXISTS roles (
  role_id SMALLINT PRIMARY KEY,
  name    TEXT NOT NULL UNIQUE,
  CHECK (name IN ('ADMIN','INSPECTOR','USER'))   -- 역할 집합 고정
);

INSERT INTO roles(role_id, name) VALUES (1,'ADMIN'),(2,'INSPECTOR'),(3,'USER')
ON CONFLICT DO NOTHING;

CREATE TABLE IF NOT EXISTS user_roles (
  user_id    BIGINT    NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
  role_id    SMALLINT  NOT NULL REFERENCES roles(role_id) ON DELETE CASCADE,
  granted_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  PRIMARY KEY(user_id, role_id) --사용자-역할 매핑(N:N)
);

-- ---------------------------------------------------------
-- 2) 자원(Resources) — MVP는 냉장 "칸"만
--    - 라벨(label)은 사람에게 보여줄 식별자, 비즈니스 키는 resource_id 사용 필수
--    - 타입/층/라벨 조합 UNIQUE로 전역 중복 방지(운영 편의)
-- ---------------------------------------------------------
CREATE TABLE IF NOT EXISTS resources (
  resource_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- 자원 ID(식별용)
  type        TEXT    NOT NULL CHECK (type IN ('FRIDGE_COMP')),  -- 이후 WASHER/DRYER/STUDYROOM/BOOK 등 확장
  floor_code  TEXT    NOT NULL DEFAULT '2F' CHECK (floor_code IN ('2F','3F','4F','5F')), -- 층 코드
  label       TEXT    NOT NULL,                                  -- UI 라벨(예: '냉장1', '냉동1')
  status      TEXT    NOT NULL DEFAULT 'ACTIVE' CHECK (status IN ('ACTIVE','OUT_OF_SERVICE')),
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(type, floor_code, label)   -- 타입별 층별 라벨 고유(운영/디버깅 편의)
);

-- ---------------------------------------------------------
-- 3) 물품(Item) — MVP: 단일 계층(묶음 1행)
--    - 활성(removed_at IS NULL) 상태에서 (resource_id, label_no) 유일
--      → 라벨 충돌 방지(제거되면 동일 라벨 재사용 가능)
--    - replaced_by_bundle_id: 라벨 교체 이력 추적(선택)
--    - group_hint: 포스트-MVP 이행(Items v2)시 매핑 힌트(현재 미사용)
-- ---------------------------------------------------------
CREATE TABLE IF NOT EXISTS item_bundles (
  bundle_id     BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- 묶음 ID(식별용)
  resource_id   BIGINT NOT NULL REFERENCES resources(resource_id) ON DELETE RESTRICT, -- 칸 ID
  owner_user_id BIGINT REFERENCES users(user_id) ON DELETE SET NULL, -- 소유자 ID
  label_no      INTEGER NOT NULL CHECK (label_no > 0),   -- 스티커 라벨 번호. 활성 상태에서 칸 단위 유일
  name          TEXT    NOT NULL,                        -- 품목명(묶음 공통)
  quantity      INTEGER NOT NULL CHECK (quantity >= 0),  -- 0 허용(부분소비 후)
  expires_on    DATE    NOT NULL,                        -- 공통 유통기한
  memo          TEXT, -- 메모
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now(), -- 생성일시
  removed_at    TIMESTAMPTZ,                             -- 전량 제거(폐기/소진)
  replaced_by_bundle_id BIGINT REFERENCES item_bundles(bundle_id) ON DELETE SET NULL, -- 교체된 묶음 ID
  group_hint    UUID, -- Items v2 이행 시 그룹 매핑 힌트(현재 미사용)
  CHECK (replaced_by_bundle_id IS NULL OR removed_at IS NOT NULL)  -- 교체되면 제거 상태여야 함
);

-- 부분 UNIQUE: "활성 레코드"에 한해 (resource_id, label_no) 유일
-- (resource_id는 이미 floor_code를 포함하므로 층별 라벨 충돌 방지)
CREATE UNIQUE INDEX IF NOT EXISTS ux_item_label_active
  ON item_bundles(resource_id, label_no) WHERE removed_at IS NULL;

-- ---------------------------------------------------------
-- 3-β) Items v2 — 묶음/개별 분리(포스트-MVP 대비, 현재 미사용)
--    - 그룹(item_groups): 라벨/공통명/메모/소유/칸(활성 라벨 유일)
--    - 개별(item_units): 각 아이템별 이름/유통기한/제거시각
--    - 전환시 "확장→백필→코드 전환→수축" 순서로 무중단 이행 가능
-- ---------------------------------------------------------
CREATE TABLE IF NOT EXISTS item_groups (
  group_id      BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- 묶음 ID(식별용)
  resource_id   BIGINT NOT NULL REFERENCES resources(resource_id) ON DELETE RESTRICT, -- 칸 ID
  owner_user_id BIGINT REFERENCES users(user_id) ON DELETE SET NULL, -- 소유자 ID
  label_no      INTEGER NOT NULL CHECK (label_no > 0), -- 묶음 라벨 번호. 활성 묶음에 대해 칸 단위 유일
  group_name    TEXT    NOT NULL, -- 묶음 공통명
  memo          TEXT, -- 메모
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now(), -- 생성일시
  removed_at    TIMESTAMPTZ, -- 묶음 전체 제거/소진
  replaced_by_group_id BIGINT REFERENCES item_groups(group_id) ON DELETE SET NULL -- 교체된 묶음 ID
);

-- 활성 그룹에 대해 (칸, 라벨) 유일
-- (resource_id는 이미 floor_code를 포함하므로 층별 라벨 충돌 방지)
CREATE UNIQUE INDEX IF NOT EXISTS ux_item_groups_label_active
  ON item_groups(resource_id, label_no) WHERE removed_at IS NULL;

-- 교체 시 제거 필수(대칭 규칙 보강)
DO $$
BEGIN 
  IF NOT EXISTS ( 
    SELECT 1 FROM pg_constraint -- 제약 조회
    WHERE conrelid='item_groups'::regclass -- 테이블 참조
      AND conname='ck_group_replaced_requires_removed' -- 제약 이름
  ) THEN
    ALTER TABLE item_groups
      ADD CONSTRAINT ck_group_replaced_requires_removed -- 제약 추가
      CHECK (replaced_by_group_id IS NULL OR removed_at IS NOT NULL);
  END IF;
END$$;

CREATE TABLE IF NOT EXISTS item_units (
  unit_id     BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- 개별 ID(식별용)
  group_id    BIGINT NOT NULL REFERENCES item_groups(group_id) ON DELETE CASCADE,
  seq_no      INTEGER NOT NULL CHECK (seq_no > 0),      -- 묶음 내 순번(1..N)
  name        TEXT    NOT NULL,                         -- 개별명(그룹명과 달라도 됨)
  expires_on  DATE    NOT NULL,                         -- 개별 유통기한
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now(), -- 생성일시
  removed_at  TIMESTAMPTZ, -- 개별 제거/소진
  UNIQUE (group_id, seq_no) -- 그룹 내 순번(1..N)
);

CREATE INDEX IF NOT EXISTS idx_item_units_group ON item_units(group_id); -- 그룹 인덱스

-- ---------------------------------------------------------
-- 4) 검사(Inspection) — 2인 세션 + 단일 제출 + 결과 불변(리비전)
--    - 자원당 진행중 세션은 1개만(동시 검사 방지)
--    - 제출되면 결과는 불변(INSERT/DELETE 금지, UPDATE는 리비전 적재)
-- ---------------------------------------------------------
CREATE TABLE IF NOT EXISTS inspection_sessions (
  session_id    BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- 세션 ID(식별용)
  resource_id   BIGINT NOT NULL REFERENCES resources(resource_id) ON DELETE RESTRICT, -- 칸 ID
  started_by    BIGINT NOT NULL REFERENCES users(user_id) ON DELETE RESTRICT, -- 시작자 ID
  status        TEXT  NOT NULL CHECK (status IN ('IN_PROGRESS','SUBMITTED','CANCELED')),
  started_at    TIMESTAMPTZ NOT NULL DEFAULT now(), -- 시작일시
  ended_at      TIMESTAMPTZ,                           -- SUBMITTED 시 필수
  submitted_by  BIGINT REFERENCES users(user_id) ON DELETE SET NULL, -- 제출자 ID
  submitted_at  TIMESTAMPTZ -- 제출일시
);

-- 자원당 진행중 세션 단일(부분 UNIQUE)
CREATE UNIQUE INDEX IF NOT EXISTS ux_inspection_res_inprog -- 자원당 진행중 세션 단일
  ON inspection_sessions(resource_id) WHERE status='IN_PROGRESS'; -- 진행중 상태일 때만

-- SUBMITTED ⇒ submitted_at/ended_at 필수
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint -- 제약 조회
    WHERE conrelid='inspection_sessions'::regclass AND conname='ck_submitted_has_ts'
  ) THEN
    ALTER TABLE inspection_sessions
      ADD CONSTRAINT ck_submitted_has_ts -- 제약 추가
      CHECK (status <> 'SUBMITTED' OR (submitted_at IS NOT NULL AND ended_at IS NOT NULL));
  END IF;
END$$;

-- IN_PROGRESS ⇒ 제출 타임스탬프 없어야 함(정합성 강화)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conrelid='inspection_sessions'::regclass AND conname='ck_inprog_has_no_submit_ts' -- 제약 이름
  ) THEN
    ALTER TABLE inspection_sessions
      ADD CONSTRAINT ck_inprog_has_no_submit_ts -- 제약 추가
      CHECK (status <> 'IN_PROGRESS' OR (submitted_at IS NULL AND ended_at IS NULL));
  END IF;
END$$;

CREATE TABLE IF NOT EXISTS inspection_participants (
  participant_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- 참가자 ID(식별용)
  session_id     BIGINT NOT NULL REFERENCES inspection_sessions(session_id) ON DELETE CASCADE,
  user_id        BIGINT NOT NULL REFERENCES users(user_id) ON DELETE RESTRICT,
  seat_no        SMALLINT NOT NULL CHECK (seat_no IN (1,2)), -- 최대 2명
  joined_at      TIMESTAMPTZ NOT NULL DEFAULT now(), -- 참여일시
  UNIQUE (session_id, seat_no),
  UNIQUE (session_id, user_id)
);

CREATE TABLE IF NOT EXISTS inspection_results (
  result_id    BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  session_id   BIGINT NOT NULL REFERENCES inspection_sessions(session_id) ON DELETE CASCADE, -- 세션 ID
  bundle_id    BIGINT REFERENCES item_bundles(bundle_id) ON DELETE SET NULL, -- 미등록 폐기 시만 NULL
  performer_participant_id BIGINT NOT NULL REFERENCES inspection_participants(participant_id) ON DELETE RESTRICT, -- 수행자 참가자 ID
  action       TEXT NOT NULL CHECK (action IN ('PASS','WARNING','DISCARD','DISCARD_WITH_PENALTY')),
  violation_type TEXT CHECK (violation_type IS NULL OR violation_type IN ('EXPIRED','NO_STICKER','PACKAGING_DEFECT','INFO_MISMATCH')),
  note         TEXT,
  performed_at TIMESTAMPTZ NOT NULL DEFAULT now(), -- 수행일시  
  version      INTEGER NOT NULL DEFAULT 1, -- 버전
  CHECK (bundle_id IS NOT NULL OR violation_type='NO_STICKER')
);

-- action ↔ violation_type 정합성 체크(비즈니스 규칙 정착)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conrelid='inspection_results'::regclass AND conname='ck_action_violation' -- 제약 이름
  ) THEN
    ALTER TABLE inspection_results
      ADD CONSTRAINT ck_action_violation -- 제약 추가
      CHECK (
        (action='PASS' AND violation_type IS NULL)
     OR (action='WARNING' AND violation_type IS NOT NULL)
     OR (action IN ('DISCARD','DISCARD_WITH_PENALTY') AND violation_type IS NOT NULL)
      );
  END IF;
END$$;

CREATE TABLE IF NOT EXISTS inspection_result_revisions (
  rev_id     BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- 리비전 ID(식별용)
  result_id  BIGINT NOT NULL REFERENCES inspection_results(result_id) ON DELETE CASCADE, -- 결과 ID
  session_id BIGINT NOT NULL,                         -- 조인 편의
  changed_by BIGINT REFERENCES users(user_id) ON DELETE SET NULL, -- 변경자 ID
  changed_at TIMESTAMPTZ NOT NULL DEFAULT now(), -- 변경일시
  reason     TEXT,                                    -- 제출 후 수정 사유(필수 취지, 트리거에서 검증)
  prev_row   JSONB NOT NULL,                          -- 변경 전 스냅샷
  new_row    JSONB NOT NULL                           -- 변경 후 스냅샷
);

-- 트리거: 제출 세션 INSERT/DELETE 차단 + UPDATE 리비전 적재(+버전 증가)
CREATE OR REPLACE FUNCTION ensure_session_not_submitted()
RETURNS TRIGGER LANGUAGE plpgsql AS $$ -- 트리거 함수
DECLARE st TEXT;
BEGIN
  SELECT status INTO st -- 세션 상태
  FROM inspection_sessions
  WHERE session_id = COALESCE(NEW.session_id, OLD.session_id)
  FOR UPDATE; -- 세션 상태 업데이트
  IF st='SUBMITTED' THEN
    RAISE EXCEPTION '이미 제출된 검사 세션입니다(결과 불변)';
  END IF;
  RETURN COALESCE(NEW, OLD);
END$$;

CREATE OR REPLACE FUNCTION trg_audit_ir_update()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
DECLARE v_status TEXT; v_reason TEXT; v_user BIGINT;
BEGIN
  SELECT status INTO v_status FROM inspection_sessions WHERE session_id = NEW.session_id; -- 세션 상태
  v_reason := current_setting('app.change_reason', true); -- 앱에서 SET LOCAL app.change_reason 로 주입
  IF current_setting('app.user_id', true) IS NOT NULL THEN
    v_user := current_setting('app.user_id')::BIGINT;     -- 앱에서 SET LOCAL app.user_id 로 주입
  END IF;
  IF v_status='SUBMITTED' AND (v_reason IS NULL OR btrim(v_reason)='') THEN -- 제출된 결과 수정에는 사유가 필요함
    RAISE EXCEPTION '제출된 검사결과 수정에는 사유(app.change_reason)가 필요합니다';
  END IF;
  INSERT INTO inspection_result_revisions(result_id, session_id, changed_by, reason, prev_row, new_row)
  VALUES (OLD.result_id, OLD.session_id, v_user, v_reason, to_jsonb(OLD), to_jsonb(NEW));
  NEW.version := OLD.version + 1;
  RETURN NEW;
END$$;

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='trg_ir_block_ins') THEN -- 제출된 결과 수정에는 사유가 필요함
    CREATE TRIGGER trg_ir_block_ins BEFORE INSERT ON inspection_results
    FOR EACH ROW EXECUTE FUNCTION ensure_session_not_submitted();
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='trg_ir_audit_upd') THEN -- 제출된 결과 수정에는 사유가 필요함
    CREATE TRIGGER trg_ir_audit_upd BEFORE UPDATE ON inspection_results
    FOR EACH ROW WHEN (OLD.* IS DISTINCT FROM NEW.*)
    EXECUTE FUNCTION trg_audit_ir_update();
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='trg_ir_block_del') THEN -- 제출된 결과 수정에는 사유가 필요함
    CREATE TRIGGER trg_ir_block_del BEFORE DELETE ON inspection_results
    FOR EACH ROW EXECUTE FUNCTION ensure_session_not_submitted();
  END IF;
END$$;

-- ---------------------------------------------------------
-- 5) 423 Locked 근거(자원 논리 락)
--    - 검사/운영 작업 중 일반 쓰기(등록/변경)를 앱에서 423으로 거절할 때의 "근거 데이터"
--    - 강제 차단 로직은 DB 트리거로 넣지 않고, 앱 미들웨어에서 판단/반환(복잡도 상승 방지)
-- ---------------------------------------------------------
CREATE TABLE IF NOT EXISTS resource_locks (
  lock_id        BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- 락 ID(식별용)
  resource_id    BIGINT NOT NULL REFERENCES resources(resource_id) ON DELETE CASCADE, -- 자원 ID
  holder_user_id BIGINT NOT NULL REFERENCES users(user_id) ON DELETE RESTRICT, -- 보유자 ID
  reason         TEXT    NOT NULL,   -- 예: 'INSPECTION_IN_PROGRESS'
  expires_at     TIMESTAMPTZ NOT NULL,  -- 자동 만료(유령 락 방지)
  created_at     TIMESTAMPTZ NOT NULL DEFAULT now(), -- 생성일시
  UNIQUE(resource_id)                  -- 자원당 1개만
);

-- ---------------------------------------------------------
-- 6) 벌점 — 원본(불변) + 조정(합산)
--    - 원본: 검사 제출 시 도메인 이벤트에 의해 생성(수정/삭제 불가)
--    - 조정: 운영자 +/- (사유 필수), 최종 점수는 합산 뷰로 조회
-- ---------------------------------------------------------
CREATE TABLE IF NOT EXISTS penalties_original (
  penalty_id  BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- 벌점 ID(식별용)
  user_id     BIGINT NOT NULL REFERENCES users(user_id) ON DELETE RESTRICT, -- 사용자 ID
  inspection_result_id BIGINT REFERENCES inspection_results(result_id) ON DELETE SET NULL, -- 결과 ID
  violation_type TEXT NOT NULL, -- 예: 'EXPIRED'
  points      INTEGER NOT NULL, -- 양수
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- 핫픽스: 양수 제약(실수 데이터 방지)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint -- 제약 조회
    WHERE conrelid='penalties_original'::regclass AND conname='ck_po_points_positive'
  ) THEN
    ALTER TABLE penalties_original
      ADD CONSTRAINT ck_po_points_positive CHECK (points > 0);
  END IF;
END$$;

-- 원본 벌점 불변성 보장(UPDATE/DELETE 차단)
CREATE OR REPLACE FUNCTION block_penalty_mutation()
RETURNS TRIGGER LANGUAGE plpgsql AS $$ -- 트리거 함수
BEGIN
  RAISE EXCEPTION '원본 벌점은 수정/삭제할 수 없습니다';
END$$;

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='trg_po_block_upd') THEN -- 제출된 결과 수정에는 사유가 필요함
    CREATE TRIGGER trg_po_block_upd BEFORE UPDATE ON penalties_original
    FOR EACH ROW EXECUTE FUNCTION block_penalty_mutation();
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='trg_po_block_del') THEN -- 제출된 결과 수정에는 사유가 필요함
    CREATE TRIGGER trg_po_block_del BEFORE DELETE ON penalties_original
    FOR EACH ROW EXECUTE FUNCTION block_penalty_mutation();
  END IF;
END$$;

CREATE TABLE IF NOT EXISTS penalties_adjustments (
  adj_id       BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- 벌점 ID(식별용)
  user_id      BIGINT  NOT NULL REFERENCES users(user_id) ON DELETE RESTRICT, -- 사용자 ID
  delta_points INTEGER NOT NULL,  -- +/- 가능(감면/추가)
  reason       TEXT    NOT NULL,  -- 사유(필수)
  created_by   BIGINT  NOT NULL REFERENCES users(user_id) ON DELETE RESTRICT, -- 생성자 ID
  created_at   TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- 집계 뷰: 카티전 곱 방지(서브집계 후 조인)
CREATE OR REPLACE VIEW v_penalties_totals AS
WITH po AS (
  SELECT user_id, SUM(points) AS original_points -- 원본 벌점
  FROM penalties_original
  GROUP BY user_id
),
pa AS (
  SELECT user_id, SUM(delta_points) AS adjusted_points -- 조정 벌점
  FROM penalties_adjustments
  GROUP BY user_id
)
SELECT u.user_id, -- 사용자 ID      
       COALESCE(po.original_points, 0) AS original_points, -- 원본 벌점
       COALESCE(pa.adjusted_points, 0) AS adjusted_points,
       COALESCE(po.original_points, 0) + COALESCE(pa.adjusted_points, 0) AS total_points -- 최종 벌점
FROM users u
LEFT JOIN po ON po.user_id = u.user_id -- 원본 벌점
LEFT JOIN pa ON pa.user_id = u.user_id; -- 조정 벌점

-- ---------------------------------------------------------
-- 7) 초기 인덱스(개선안2 세트)
--    - MVP 주 조회패턴 최적화(부분 인덱스 + 커버링), FK 조인 가속
--    - 운영 중 추가 인덱스가 필요하면 CONCURRENTLY로 보강 권장
-- ---------------------------------------------------------
-- FK/조인 기반
CREATE INDEX IF NOT EXISTS idx_ir_session      ON inspection_results(session_id); -- 결과 세션  
CREATE INDEX IF NOT EXISTS idx_ir_performer    ON inspection_results(performer_participant_id); -- 결과 수행자
CREATE INDEX IF NOT EXISTS idx_ip_session      ON inspection_participants(session_id); -- 참가자 세션
CREATE INDEX IF NOT EXISTS idx_ip_user         ON inspection_participants(user_id); -- 참가자 사용자
CREATE INDEX IF NOT EXISTS idx_po_user         ON penalties_original(user_id); -- 원본 벌점 사용자
CREATE INDEX IF NOT EXISTS idx_pa_user         ON penalties_adjustments(user_id);

-- 활성 아이템 조회 최적화(커버링 + 부분 인덱스)
CREATE INDEX IF NOT EXISTS idx_item_owner_expires_covering -- 소유자 유통기한 최적화
  ON item_bundles(owner_user_id, expires_on, created_at DESC)   -- 소유자 유통기한 최적화
  INCLUDE (bundle_id, name, quantity) -- 번들 아이디, 이름, 수량
  WHERE removed_at IS NULL; -- 제거되지 않은 경우

CREATE INDEX IF NOT EXISTS idx_item_resource_label_covering -- 리소스 라벨 최적화
  ON item_bundles(resource_id, label_no) -- 리소스 라벨 최적화
  INCLUDE (bundle_id, name, quantity, expires_on, owner_user_id, created_at) -- 번들 아이디, 이름, 수량, 유통기한, 소유자, 생성일시
  WHERE removed_at IS NULL; -- 제거되지 않은 경우

-- 진행중 세션 빠른 조회(부분 인덱스)
CREATE INDEX IF NOT EXISTS idx_sessions_inprog_started -- 진행중 세션 빠른 조회
  ON inspection_sessions(status, started_at DESC) -- 진행중 세션 빠른 조회
  WHERE status = 'IN_PROGRESS'; -- 진행중 상태일 때만

-- 결과 타임라인(커버링)
CREATE INDEX IF NOT EXISTS idx_ir_session_time_covering -- 결과 타임라인 최적화
  ON inspection_results(session_id, performed_at) -- 결과 타임라인 최적화
  INCLUDE (result_id, action, violation_type, note, version, performer_participant_id); -- 결과 아이디, 액션, 위반 타입, 메모, 버전, 수행자 참가자 아이디

-- (옵션) 키워드 검색: GIN(TRGM) — 초기 데이터 적으면 보류 가능
CREATE INDEX IF NOT EXISTS idx_item_bundles_name_trgm -- 번들 이름 최적화
  ON item_bundles USING gin (name gin_trgm_ops); -- 번들 이름 최적화
CREATE INDEX IF NOT EXISTS idx_item_bundles_memo_trgm -- 번들 메모 최적화
  ON item_bundles USING gin (memo gin_trgm_ops); -- 번들 메모 최적화


-- ---------------------------------------------------------
-- 8) (옵션) 권한 잠금 — dcs_app/dcs_read 롤이 존재할 때만 적용
--    - 마이그/DDL은 관리자 롤, 앱 커넥션은 dcs_app, 리드 전용은 dcs_read 권장
--    - 원본 벌점 UPDATE/DELETE는 트리거에 더해 권한도 REVOKE(이중 안전망)
-- ---------------------------------------------------------
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname='dcs_app') THEN
    EXECUTE 'GRANT USAGE ON SCHEMA public TO dcs_app'; -- 관리자 권한
    EXECUTE 'GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO dcs_app'; -- 관리자 권한
    EXECUTE 'GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO dcs_app'; -- 관리자 권한
    EXECUTE 'ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO dcs_app'; -- 관리자 권한
    EXECUTE 'ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT USAGE, SELECT ON SEQUENCES TO dcs_app'; -- 관리자 권한
    EXECUTE 'REVOKE UPDATE, DELETE ON penalties_original FROM dcs_app';
  END IF;

  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname='dcs_read') THEN
    EXECUTE 'GRANT USAGE ON SCHEMA public TO dcs_read'; -- 관리자 권한  
    EXECUTE 'GRANT SELECT ON ALL TABLES IN SCHEMA public TO dcs_read'; -- 관리자 권한
    EXECUTE 'GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO dcs_read'; -- 관리자 권한
    EXECUTE 'ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON TABLES TO dcs_read'; -- 관리자 권한
    EXECUTE 'ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT USAGE, SELECT ON SEQUENCES TO dcs_read'; -- 관리자 권한
    EXECUTE 'REVOKE UPDATE, DELETE ON penalties_original FROM dcs_read';
  END IF;
END$$;

COMMIT;

-- =========================================================
-- 실행 메모:
--  • 관리자 계정 자동 생성 원하면:
--      SET app.admin_password_hash = '$2b$12$.........................';
--      \i 이_파일.sql
--  • API 에러 매핑(권장):
--      UNIQUE/경합=409, CHECK/FK=422, 검사중/락=423, 레이트=429
--  • 라벨 교체(동일 라벨 재사용)는 트랜잭션으로 원자적 처리 권장
-- =========================================================


-- =========================================================
-- [향후 구현 방향(로드맵) — 참고 주석]
--
-- R1) 하드닝 ① (성능/신뢰성/보안)
--  - 작성계 멱등성: Idempotency-Key 수용(캐시/스토어)
--  - 레이트리밋 세분화: 사용자·엔드포인트·버스트
--  - SSE 관측: 연결 수/하트비트/지연/드롭률 대시보드
--  - OpenAPI 스냅샷/에러 카탈로그 확정
--
-- R2) 알림 파이프라인
--  - outbox/due_tasks(예약·재시도·백오프), 워커 멱등 처리
--  - 유통기한 D-1, 검사 결과 알림, 실패 재시도/중복억제
--  - 포그라운드=SSE, 백그라운드=Web Push 병행
--
-- R3) PWA + Web Push
--  - 서비스워커/오프라인 캐시(읽기 우선), 푸시 구독/해지
--  - iOS 홈화면 가이드, 딥링크(푸시 탭→대상화면)
--
-- R4) Items v2 전환(개별 아이템 이름/유통기한/제거시각)
--  - 확장(현 스키마 준비完) → 백필(item_bundles → groups/units)
--  - 새 API 병행/섀도우-쓰기 → 프론트 전환 → 구 경로 수축
--  - SSE 이벤트 키를 group_id/unit_id로 명확화
--
-- R5) 자원 확장(세탁실/스터디룸/도서관)
--  - type 추가 + 예약/대출/반납 도메인 테이블(추가만으로 확장)
--  - EXCLUDE/파티셔닝/아카이빙은 데이터 규모 커질 때 도입
--
-- R6) 운영/관측 고도화
--  - pg_stat_statements 대시보드, 인덱스 효율 뷰
--  - 슬로우쿼리/락 경합 알림, 주간 점검 런북
--
-- 주의:
--  - TRGM/GIN 인덱스는 데이터가 커지기 전까지 보류 가능(공간/빌드비용 절감)
--  - resource_locks는 "근거 데이터"로 유지, 쓰기 차단은 앱 미들웨어에서 423 반환
--  - inspection_results 불변성은 MVP 기간 유지(나중에 저장함수로 점진 전환 고려)
-- =========================================================
